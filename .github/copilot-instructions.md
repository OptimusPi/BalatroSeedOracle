# BalatroSeedOracle Agent Guide
- **Primary Stack**: Avalonia (.NET 9) desktop app with CommunityToolkit.Mvvm, DuckDB via DuckDB.NET, and the Motely search engine submodule in `external/Motely`.
- **Entry Points**: `src/Program.cs` enables `DebugLogger`; `src/App.axaml.cs` configures DI, preloads sprites, and shows `Views/MainWindow` with the Balatro shader intro.
- **DI Setup**: Register new services/view-models through `src/Extensions/ServiceCollectionExtensions.cs` so `App` can resolve them and `ServiceHelper.GetService<T>` continues working.
- **MVVM Pattern**: Views bind to ViewModels using `[ObservableProperty]` from CommunityToolkit; generated partial members live alongside manual logic (see `src/ViewModels/FilterBuilderItemViewModel.cs`).
- **Filter Wrapper Pattern**: Visual Builder uses `FilterBuilderItemViewModel` as a thin wrapper over `Models/ItemConfig`; mutate `ItemConfig` and sync children via `SyncChildrenToConfig()` before serialization.
- **Modal Orchestration**: `FiltersModalViewModel` (and tab ViewModels under `src/ViewModels/FilterTabs/`) maintain the master `ItemConfigs` dictionary; always update that dictionary when adding/removing UI items.
- **Filter Serialization**: Use `FilterSerializationService` to write `MotelyJsonConfig`—it enforces author metadata, compact arrays, and keeps cache invalidation in sync with `ConfigurationService`.
- **Filter Storage**: Filters live under `JsonItemFilters/` relative to the working directory; `ConfigurationService` assumes the app is launched from repo root and will auto-create `_UNSAVED_*.json` temp files there.
- **Filter Cache**: `FilterCacheService` eagerly loads all filter JSON at startup; call `InvalidateFilter`/`RemoveFilter` after edits to keep the in-memory cache and search UI aligned.
- **Search Lifecycle**: `SearchManager` owns `SearchInstance` objects keyed by `filter_deck_stake`; always request instances through `SearchManager` so DuckDB files and lifecycle events stay consistent.
- **Search Engine Integration**: `SearchInstance.RunSearchInProcess` converts Motely JSON to specialized filters, writes results via DuckDB appenders, and raises progress events—avoid bypassing this path unless you also handle result flushing.
- **DuckDB Files**: Each search writes to `SearchResults/<filter>_<deck>_<stake>.db`; call `SearchInstance.ForceFlush()` or wait for the normal completion path before querying to avoid missing buffered rows.
- **Stopping Searches**: Editing a filter should trigger `SearchManager.StopSearchesForFilter(filterName)` to invalidate stale DuckDB data before saving new JSON.
- **Quick Tests**: `SearchManager.RunQuickSearchAsync` spins an in-memory config against a temp DuckDB; reuse it for validation rather than cloning `SearchInstance` manually.
- **Sprite Loading**: `SpriteService.Instance` caches all UI textures; heavy initialization happens once during `App` startup, so load new assets through that singleton instead of new file IO.
- **Audio Pipeline**: `SoundFlowAudioManager` (registered singleton) drives the 8-track mix; dispose or request it through DI rather than instantiating directly.
- **Unified Logging**: Prefer `Helpers/DebugLogger` for diagnostics; `Program` already enables global logging, and many services rely on its structured categories.
- **Filter Tabs**: `FilterTabViewModelBase` centralizes shared logic (search, grouping, auto-save); new tab behaviors should extend it to inherit the auto-save scheduler and zone event hooks.
- **Clause Editing**: Visual builder OR/AND trays produce nested `ItemConfig.Children`; ensure you call `CommitOrClause`/`CommitAndClause` helpers or replicate their pattern when introducing new clause types.
- **Motely Configs**: Scoring relies on `config.Should` with `score` values and optional `mode`; when building configs in code, run `config.PostProcess()` before handing them to Motely.
- **User Profile**: `UserProfileService` persists UI state and search resume data; when adding long-running interactions, flush via `FlushProfile()` during shutdown to match existing behavior.
- **Favorites & Stickers**: Visual builder toggles update every `ItemConfig` plus UI copies; reuse `ApplyEditionStickersSeal` and `ApplyStickerLogic` when extending customization buttons.
- **Build Commands**: From repo root run `dotnet restore src/BalatroSeedOracle.csproj` then `dotnet build src/BalatroSeedOracle.csproj`; launch with `dotnet run -c Debug --project src/BalatroSeedOracle.csproj` (use `Release` for full-speed searches).
- **Submodule Setup**: Ensure Motely assets are available with `git submodule update --init --recursive`; many search services assume compiled Motely binaries exist.
- **Large Assets**: `SearchResults/` and `WordLists/` contain runtime data; treat them as generated artifacts and avoid checking changes into source without explicit intent.
- **UI Styling**: Global styles live under `src/Styles/`; controls often expect matching theme resources, so update the style dictionaries when adding new visual states.
- **Testing Hooks**: No formal test suite is present; validate changes by launching the app and using the Filter Designer + Quick Search to ensure DuckDB output matches expectations.
- **Platform Notes**: Avalonia runs cross-platform, but file paths assume macOS/Linux-style separators; keep new IO logic platform-neutral and prefer `Path.Combine`.
