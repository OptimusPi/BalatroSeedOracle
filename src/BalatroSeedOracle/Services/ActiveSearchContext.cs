using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using BalatroSeedOracle.Models;
using Motely;
using Motely.Filters;
using DebugLogger = BalatroSeedOracle.Helpers.DebugLogger;

namespace BalatroSeedOracle.Services;

/// <summary>
/// Context holding a Motely search instance for UI binding.
/// 
/// Delegates everything to IMotelySearchContext - Motely owns all database operations.
/// ZERO database code here - just pass-through to Motely.
/// </summary>
public sealed class ActiveSearchContext : IDisposable
{
    private readonly IMotelySearchContext _context;
    private readonly MotelyJsonConfig _config;
    
    private bool _hasNewResults;

    /// <summary>
    /// Create an ActiveSearchContext wrapping a Motely search context.
    /// </summary>
    public ActiveSearchContext(IMotelySearchContext context, MotelyJsonConfig config)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _config = config ?? throw new ArgumentNullException(nameof(config));
    }

    // === Identity - from Motely ===
    
    /// <summary>SearchId is generated by Motely, not BSO</summary>
    public string SearchId => _context.SearchId;
    
    /// <summary>FilterId is generated by Motely, not BSO</summary>
    public string FilterId => _context.FilterId;
    
    public string FilterName => _config.Name ?? SearchId;
    
    public MotelyJsonConfig Config => _config;
    
    // Legacy compatibility - ConfigPath no longer used
    public string ConfigPath => "";
    
    // Legacy compatibility - DatabasePath is no longer used directly by BSO
    // SQL Editor feature will check this and show appropriate message if empty
    public string DatabasePath => "";  // Database is managed internally by Motely

    // === Status - from Motely ===
    
    public bool IsRunning => _context.Status == MotelySearchStatus.Running;
    public bool IsPaused => _context.Status == MotelySearchStatus.Paused;
    public MotelySearchStatus Status => _context.Status;
    public TimeSpan ElapsedTime => _context.ElapsedTime;
    public TimeSpan SearchDuration => _context.ElapsedTime;
    public long TotalSeedsSearched => _context.TotalSeedsSearched;
    public long MatchingSeeds => _context.MatchingSeeds;
    public long FilteredSeeds => _context.FilteredSeeds;

    // === Results - from Motely (Motely queries its own database) ===
    
    /// <summary>
    /// Result count - Motely queries its internal storage
    /// </summary>
    public int ResultCount => _context.ResultCount;
    
    /// <summary>
    /// Column names for result data
    /// </summary>
    public IReadOnlyList<string> ColumnNames => _context.ColumnNames;
    
    public bool HasNewResultsSinceLastQuery => _hasNewResults;
    
    public void AcknowledgeResultsQueried() => _hasNewResults = false;
    
    internal void MarkNewResults() => _hasNewResults = true;

    /// <summary>
    /// Get a page of results - Motely handles the query
    /// </summary>
    public async Task<List<SearchResult>> GetResultsPageAsync(int offset, int count)
    {
        try
        {
            var motelyResults = _context.GetResults(offset, count);
            var results = motelyResults.Select(r => new SearchResult
            {
                Seed = r.Seed,
                TotalScore = r.Score,
                Scores = r.Tallies?.ToArray() ?? Array.Empty<int>()
            }).ToList();
            
            return await Task.FromResult(results);
        }
        catch (Exception ex)
        {
            DebugLogger.LogError("ActiveSearchContext", $"GetResultsPageAsync failed: {ex.Message}");
            return await Task.FromResult(new List<SearchResult>());
        }
    }

    /// <summary>
    /// Get top results - Motely handles the query
    /// </summary>
    public async Task<List<SearchResult>> GetTopResultsAsync(string orderBy, bool ascending, int limit)
    {
        try
        {
            // Note: IMotelySearchContext.GetResults always orders by score desc
            // Future: could add ordering parameter to Motely interface
            var motelyResults = _context.GetTopResults(limit);
            var results = motelyResults.Select(r => new SearchResult
            {
                Seed = r.Seed,
                TotalScore = r.Score,
                Scores = r.Tallies?.ToArray() ?? Array.Empty<int>()
            }).ToList();
            
            return await Task.FromResult(results);
        }
        catch (Exception ex)
        {
            DebugLogger.LogError("ActiveSearchContext", $"GetTopResultsAsync failed: {ex.Message}");
            return await Task.FromResult(new List<SearchResult>());
        }
    }

    public async Task<int> GetResultCountAsync() => await Task.FromResult(ResultCount);

    // === Control - delegate to Motely ===
    
    public void Start() => _context.Start();
    public void Pause() => _context.Pause();
    public void PauseSearch() => _context.Pause();
    public void Stop() => _context.Cancel();
    public void StopSearch() => _context.Cancel();
    
    public MotelyJsonConfig? GetFilterConfig() => _config;

    // === Events for UI binding ===
    
    public event EventHandler<SearchResultEventArgs>? SearchStarted;
    public event EventHandler<SearchResultEventArgs>? SearchCompleted;
    public event EventHandler<SearchProgress>? ProgressUpdated;
    public event EventHandler<SearchResult>? ResultFound; // Real-time result streaming (like Motely.WASM POC)

    // Internal methods to raise events (called by SearchManager or polling)
    internal void RaiseSearchStarted() => SearchStarted?.Invoke(this, new SearchResultEventArgs());
    internal void RaiseSearchCompleted() => SearchCompleted?.Invoke(this, new SearchResultEventArgs());
    internal void RaiseProgressUpdated(SearchProgress progress) => ProgressUpdated?.Invoke(this, progress);
    internal void RaiseResultFound(SearchResult result) => ResultFound?.Invoke(this, result);

    public void Dispose()
    {
        _context.Dispose();
    }
}

/// <summary>
/// Event args for search events (placeholder for additional data if needed)
/// </summary>
public class SearchResultEventArgs : EventArgs
{
}
