using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using NAudio.Vorbis;
using NAudio.Wave;
using NAudio.Wave.SampleProviders;
using NAudio.Dsp;

namespace BalatroSeedOracle.Services
{
    /// <summary>
    /// Multi-track audio manager with REAL per-track FFT analysis
    /// Plays 8 independent audio streams simultaneously with individual volume control and spectrum analysis
    /// </summary>
    public class SoundFlowAudioManager : IDisposable
    {
        private const int FFT_SIZE = 2048;
        private const int SAMPLE_RATE = 44100;
        private const int UPDATE_RATE_MS = 16; // ~60 FPS

        // Audio output
        private readonly WaveOutEvent _waveOut;
        private readonly MixingSampleProvider _mixer;

        // Track data
        private readonly AudioTrack[] _tracks = new AudioTrack[8];
        private readonly string[] _trackNames =
        {
            "Bass1", "Bass2",
            "Drums1", "Drums2",
            "Chords1", "Chords2",
            "Melody1", "Melody2"
        };

        // Update loop
        private CancellationTokenSource? _cancellationTokenSource;
        private Task? _updateTask;
        private bool _isDisposed;

        #region Public Properties - Per-Track Intensities (REAL FFT values!)

        public float Bass1Intensity { get; private set; }
        public float Bass2Intensity { get; private set; }
        public float Drums1Intensity { get; private set; }
        public float Drums2Intensity { get; private set; }
        public float Chords1Intensity { get; private set; }
        public float Chords2Intensity { get; private set; }
        public float Melody1Intensity { get; private set; }
        public float Melody2Intensity { get; private set; }

        #endregion

        #region Public Properties - Per-Track Dominant Frequency (Hz)

        public float Bass1Frequency { get; private set; }
        public float Bass2Frequency { get; private set; }
        public float Drums1Frequency { get; private set; }
        public float Drums2Frequency { get; private set; }
        public float Chords1Frequency { get; private set; }
        public float Chords2Frequency { get; private set; }
        public float Melody1Frequency { get; private set; }
        public float Melody2Frequency { get; private set; }

        #endregion

        #region Public Properties - Master Controls

        private float _masterVolume = 1.0f;
        public float MasterVolume
        {
            get => _masterVolume;
            set
            {
                _masterVolume = Math.Clamp(value, 0f, 1f);
                if (_waveOut != null)
                    _waveOut.Volume = _masterVolume;
            }
        }

        #endregion

        public SoundFlowAudioManager()
        {
            try
            {
                // Initialize audio output
                _waveOut = new WaveOutEvent
                {
                    DesiredLatency = 100,
                    NumberOfBuffers = 2
                };

                _mixer = new MixingSampleProvider(WaveFormat.CreateIeeeFloatWaveFormat(SAMPLE_RATE, 2))
                {
                    ReadFully = true
                };

                _waveOut.Init(_mixer);

                // Load all 8 tracks
                LoadAllTracks();

                // Start playback immediately
                Play();

                // Start FFT analysis loop
                StartUpdateLoop();

                Console.WriteLine("[SoundFlowAudioManager] Initialized with 8 independent tracks and REAL FFT analysis");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[SoundFlowAudioManager] ERROR: Initialization failed: {ex.Message}");
                throw;
            }
        }

        private void LoadAllTracks()
        {
            // Find audio directory
            var possiblePaths = new[]
            {
                Path.Combine(Directory.GetCurrentDirectory(), "Assets", "Audio"),
                Path.Combine(Directory.GetCurrentDirectory(), "src", "Assets", "Audio"),
            };

            string? audioDir = null;
            foreach (var path in possiblePaths)
            {
                if (Directory.Exists(path))
                {
                    audioDir = path;
                    break;
                }
            }

            if (audioDir == null)
            {
                throw new DirectoryNotFoundException("Assets/Audio directory not found");
            }

            // Load each track
            for (int i = 0; i < 8; i++)
            {
                var fileName = $"{_trackNames[i]}.ogg";
                var filePath = Path.Combine(audioDir, fileName);

                if (!File.Exists(filePath))
                {
                    throw new FileNotFoundException($"Audio file not found: {filePath}");
                }

                _tracks[i] = new AudioTrack(_trackNames[i], filePath, _mixer);
                Console.WriteLine($"[SoundFlowAudioManager] Loaded: {fileName}");
            }
        }

        private void StartUpdateLoop()
        {
            _cancellationTokenSource = new CancellationTokenSource();
            _updateTask = Task.Run(() => UpdateLoop(_cancellationTokenSource.Token));
        }

        private async Task UpdateLoop(CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    // Update FFT for all tracks and extract intensity/frequency
                    UpdateTrackAnalysis();

                    await Task.Delay(UPDATE_RATE_MS, cancellationToken);
                }
                catch (OperationCanceledException)
                {
                    break;
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[SoundFlowAudioManager] Update loop error: {ex.Message}");
                }
            }
        }

        private void UpdateTrackAnalysis()
        {
            // Track 0: Bass1
            (Bass1Intensity, Bass1Frequency) = _tracks[0].GetCurrentAnalysis();

            // Track 1: Bass2
            (Bass2Intensity, Bass2Frequency) = _tracks[1].GetCurrentAnalysis();

            // Track 2: Drums1
            (Drums1Intensity, Drums1Frequency) = _tracks[2].GetCurrentAnalysis();

            // Track 3: Drums2
            (Drums2Intensity, Drums2Frequency) = _tracks[3].GetCurrentAnalysis();

            // Track 4: Chords1
            (Chords1Intensity, Chords1Frequency) = _tracks[4].GetCurrentAnalysis();

            // Track 5: Chords2
            (Chords2Intensity, Chords2Frequency) = _tracks[5].GetCurrentAnalysis();

            // Track 6: Melody1
            (Melody1Intensity, Melody1Frequency) = _tracks[6].GetCurrentAnalysis();

            // Track 7: Melody2
            (Melody2Intensity, Melody2Frequency) = _tracks[7].GetCurrentAnalysis();
        }

        #region Public API - Volume/Mute Control

        public void SetTrackVolume(int trackIndex, float volume)
        {
            if (trackIndex < 0 || trackIndex >= 8)
                throw new ArgumentOutOfRangeException(nameof(trackIndex));

            _tracks[trackIndex].SetVolume(volume);
        }

        public void SetTrackMuted(int trackIndex, bool muted)
        {
            if (trackIndex < 0 || trackIndex >= 8)
                throw new ArgumentOutOfRangeException(nameof(trackIndex));

            _tracks[trackIndex].SetMuted(muted);
        }

        #endregion

        #region Public API - Playback Controls

        public void Play()
        {
            _waveOut?.Play();
        }

        public void Pause()
        {
            _waveOut?.Pause();
        }

        public void Stop()
        {
            _waveOut?.Stop();
        }

        #endregion

        #region IDisposable

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;

            // Stop update loop
            _cancellationTokenSource?.Cancel();
            _updateTask?.Wait(1000);
            _cancellationTokenSource?.Dispose();

            // Stop playback
            _waveOut?.Stop();
            _waveOut?.Dispose();

            // Dispose all tracks
            foreach (var track in _tracks)
            {
                track?.Dispose();
            }

            Console.WriteLine("[SoundFlowAudioManager] Disposed");
        }

        #endregion

        /// <summary>
        /// Represents a single audio track with FFT analysis
        /// </summary>
        private class AudioTrack : IDisposable
        {
            private readonly string _name;
            private readonly LoopStream _loopStream;
            private readonly VolumeSampleProvider _volumeProvider;
            private readonly FFTSampleProvider _fftProvider;

            public AudioTrack(string name, string filePath, MixingSampleProvider mixer)
            {
                _name = name;

                // Load Vorbis file
                var vorbisReader = new VorbisWaveReader(filePath);

                // Create looping stream
                _loopStream = new LoopStream(vorbisReader);

                // Convert to sample provider
                var sampleProvider = _loopStream.ToSampleProvider();

                // Resample to 44.1kHz stereo if needed
                ISampleProvider resampled = sampleProvider;
                if (sampleProvider.WaveFormat.SampleRate != SAMPLE_RATE ||
                    sampleProvider.WaveFormat.Channels != 2)
                {
                    var mediaFoundationResampler = new MediaFoundationResampler(
                        sampleProvider.ToWaveProvider(),
                        WaveFormat.CreateIeeeFloatWaveFormat(SAMPLE_RATE, 2)
                    );
                    resampled = mediaFoundationResampler.ToSampleProvider();
                }

                // Add FFT analyzer
                _fftProvider = new FFTSampleProvider(resampled);

                // Add volume control
                _volumeProvider = new VolumeSampleProvider(_fftProvider)
                {
                    Volume = 1.0f
                };

                // Add to mixer
                mixer.AddMixerInput(_volumeProvider);
            }

            public void SetVolume(float volume)
            {
                _volumeProvider.Volume = Math.Clamp(volume, 0f, 1f);
            }

            public void SetMuted(bool muted)
            {
                _volumeProvider.Volume = muted ? 0f : 1f;
            }

            public (float intensity, float frequency) GetCurrentAnalysis()
            {
                return _fftProvider.GetAnalysis();
            }

            public void Dispose()
            {
                _loopStream?.Dispose();
            }
        }

        /// <summary>
        /// Looping audio stream wrapper
        /// </summary>
        private class LoopStream : WaveStream
        {
            private readonly WaveStream _sourceStream;

            public LoopStream(WaveStream sourceStream)
            {
                _sourceStream = sourceStream;
            }

            public override WaveFormat WaveFormat => _sourceStream.WaveFormat;
            public override long Length => _sourceStream.Length;
            public override long Position
            {
                get => _sourceStream.Position;
                set => _sourceStream.Position = value;
            }

            public override int Read(byte[] buffer, int offset, int count)
            {
                int totalBytesRead = 0;

                while (totalBytesRead < count)
                {
                    int bytesRead = _sourceStream.Read(buffer, offset + totalBytesRead, count - totalBytesRead);

                    if (bytesRead == 0)
                    {
                        // End of stream - loop back to beginning
                        _sourceStream.Position = 0;
                    }

                    totalBytesRead += bytesRead;
                }

                return totalBytesRead;
            }

            protected override void Dispose(bool disposing)
            {
                if (disposing)
                {
                    _sourceStream?.Dispose();
                }
                base.Dispose(disposing);
            }
        }

        /// <summary>
        /// Sample provider with real-time FFT analysis
        /// </summary>
        private class FFTSampleProvider : ISampleProvider
        {
            private readonly ISampleProvider _source;
            private readonly Complex[] _fftBuffer = new Complex[FFT_SIZE];
            private readonly float[] _fftWindow = new float[FFT_SIZE];
            private readonly float[] _audioBuffer = new float[FFT_SIZE];
            private int _audioBufferPos = 0;

            private float _currentIntensity = 0f;
            private float _currentFrequency = 0f;
            private readonly object _analysisLock = new object();

            public WaveFormat WaveFormat => _source.WaveFormat;

            public FFTSampleProvider(ISampleProvider source)
            {
                _source = source;

                // Create Hann window for FFT
                for (int i = 0; i < FFT_SIZE; i++)
                {
                    _fftWindow[i] = 0.5f * (1 - MathF.Cos(2 * MathF.PI * i / (FFT_SIZE - 1)));
                }
            }

            public int Read(float[] buffer, int offset, int count)
            {
                int samplesRead = _source.Read(buffer, offset, count);

                // Collect samples for FFT (using mono mix from stereo)
                for (int i = 0; i < samplesRead; i++)
                {
                    if (_audioBufferPos < FFT_SIZE)
                    {
                        // Mix stereo to mono
                        float sample = buffer[offset + i];
                        if (WaveFormat.Channels == 2)
                        {
                            // Average left and right
                            if (i % 2 == 0 && i + 1 < samplesRead)
                            {
                                sample = (buffer[offset + i] + buffer[offset + i + 1]) * 0.5f;
                            }
                            else
                            {
                                continue;
                            }
                        }

                        _audioBuffer[_audioBufferPos++] = sample;

                        // When buffer is full, perform FFT
                        if (_audioBufferPos >= FFT_SIZE)
                        {
                            PerformFFT();
                            _audioBufferPos = 0;
                        }
                    }
                }

                return samplesRead;
            }

            private void PerformFFT()
            {
                // Apply window and copy to FFT buffer
                for (int i = 0; i < FFT_SIZE; i++)
                {
                    _fftBuffer[i].X = _audioBuffer[i] * _fftWindow[i];
                    _fftBuffer[i].Y = 0;
                }

                // Perform FFT
                FastFourierTransform.FFT(true, (int)Math.Log(FFT_SIZE, 2), _fftBuffer);

                // Calculate magnitude spectrum and find dominant frequency
                float maxMagnitude = 0f;
                int maxBin = 0;
                float totalEnergy = 0f;

                // Only analyze first half (Nyquist)
                int bins = FFT_SIZE / 2;
                for (int i = 0; i < bins; i++)
                {
                    float magnitude = MathF.Sqrt(_fftBuffer[i].X * _fftBuffer[i].X + _fftBuffer[i].Y * _fftBuffer[i].Y);

                    totalEnergy += magnitude * magnitude;

                    if (magnitude > maxMagnitude)
                    {
                        maxMagnitude = magnitude;
                        maxBin = i;
                    }
                }

                // Calculate RMS intensity (normalized)
                float rms = MathF.Sqrt(totalEnergy / bins);
                float intensity = Math.Clamp(rms * 10f, 0f, 1f); // Scale factor to get 0-1 range

                // Calculate dominant frequency in Hz
                float frequency = maxBin * (SAMPLE_RATE / 2f) / bins;

                // Update analysis results (thread-safe)
                lock (_analysisLock)
                {
                    _currentIntensity = intensity;
                    _currentFrequency = frequency;
                }
            }

            public (float intensity, float frequency) GetAnalysis()
            {
                lock (_analysisLock)
                {
                    return (_currentIntensity, _currentFrequency);
                }
            }
        }
    }
}
